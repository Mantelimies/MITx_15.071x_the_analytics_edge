ska---
title: '"The Analytics Edge Week 4"'
author: "Joona Rauhamäki"
date: "23 kesäkuuta 2016"
output: html_document
---

# The Analytics Edge Week 4

#UNDERSTANDING WHY PEOPLE VOTE

In August 2006 three researchers (Alan Gerber and Donald Green of Yale University, and Christopher Larimer of the University of Northern Iowa) carried out a large scale field experiment in Michigan, USA to test the hypothesis that one of the reasons people vote is social, or extrinsic, pressure. To quote the first paragraph of their 2008 research paper:

Among the most striking features of a democratic political system is the participation of millions of voters in elections. Why do large numbers of people vote, despite the fact that ... "the casting of a single vote is of no significance where there is a multitude of electors"? One hypothesis is adherence to social norms. Voting is widely regarded as a citizen duty, and citizens worry that others will think less of them if they fail to participate in elections. Voters' sense of civic duty has long been a leading explanation of vote turnout...

In this homework problem we will use both logistic regression and classification trees to analyze the data they collected.

THE DATA

The researchers grouped about 344,000 voters into different groups randomly - about 191,000 voters were a "control" group, and the rest were categorized into one of four "treatment" groups. These five groups correspond to five binary variables in the dataset.

"Civic Duty" (variable civicduty) group members were sent a letter that simply said "DO YOUR CIVIC DUTY - VOTE!"
"Hawthorne Effect" (variable hawthorne) group members were sent a letter that had the "Civic Duty" message plus the additional message "YOU ARE BEING STUDIED" and they were informed that their voting behavior would be examined by means of public records.
"Self" (variable self) group members received the "Civic Duty" message as well as the recent voting record of everyone in that household and a message stating that another message would be sent after the election with updated records.
"Neighbors" (variable neighbors) group members were given the same message as that for the "Self" group, except the message not only had the household voting records but also that of neighbors - maximizing social pressure.
"Control" (variable control) group members were not sent anything, and represented the typical voting situation.
Additional variables include sex (0 for male, 1 for female), yob (year of birth), and the dependent variable voting (1 if they voted, 0 otherwise).

As usual, let's start with emptying the workspace
```{r}
rm (list = ls(all=T))
``` 

## Problem 1.1 - Exploration and Logistic Regression


We will first get familiar with the data. Load the CSV file gerber.csv into R. What proportion of people in this dataset voted in this election?
```{r}
voters = read.csv("gerber.csv")
str(voters)
nrow(voters[which(voters$voting == 1),])/nrow(voters)
```
a : 0.3158996


## Problem 1.2 - Exploration and Logistic Regression

Which of the four "treatment groups" had the largest percentage of people who actually voted (voting = 1)?

```{r}
nrow(voters[voters$hawthorne == 1 & voters$voting == 1,])/nrow(voters[voters$hawthorne == 1,])
tapply(voters$voting, voters$hawthorne, mean)
tapply(voters$voting, voters$civicduty, mean)
tapply(voters$voting, voters$neighbors, mean)
tapply(voters$voting, voters$self,mean)
tapply(voters$voting, voters$control, mean)
```


## Problem 1.3 - Exploration and Logistic Regression


Build a logistic regression model for voting using the four treatment group variables as the independent variables (civicduty, hawthorne, self, and neighbors). Use all the data to build the model (DO NOT split the data into a training set and testing set). Which of the following coefficients are significant in the logistic regression model? Select all that apply.

```{r}
logVoters = glm(voting ~ civicduty + hawthorne + self + neighbors, data = voters, family = binomial)
summary(logVoters)
```
a: all

## Problem 1.4 - Exploration and Logistic Regression

Using a threshold of 0.3, what is the accuracy of the logistic regression model? (When making predictions, you don't need to use the newdata argument since we didn't split our data.)

```{r}
pred = predict(logVoters, type = "response")
table(voters$voting, pred > 0.3)
(134513+51966)/(134513+51966+100875+56730)
```
a: 0.5419578




##Problem 1.5 - Exploration and Logistic Regression


Using a threshold of 0.5, what is the accuracy of the logistic regression model?
```{r}
table(voters$voting, pred > 0.5)
(235388)/(235388+108696)
```
a: 0.6841004

##Problem 1.6 - Exploration and Logistic Regression


Compare your previous two answers to the percentage of people who did not vote (the baseline accuracy) and compute the AUC of the model. What is happening here?
```{r}
table(voters$voting)
baseline = nrow(voters[voters$voting == 0,])/length(voters$voting)
baseline

library (ROCR)
ROCRpred = prediction(pred, voters$voting)
as.numeric(performance(ROCRpred, "auc")@y.values)

ROCRperf = performance(ROCRpred, "tpr", "fpr")
plot(ROCRperf, colorize = T)
```

a: "Even though all of the variables are significant, this is a weak predictive model."

## Problem 2.1 - Trees

We will now try out trees. Build a CART tree for voting using all data and the same four treatment variables we used before. Don't set the option method="class" - we are actually going to create a regression tree here. We are interested in building a tree to explore the fraction of people who vote, or the probability of voting. We’d like CART to split our groups if they have different probabilities of voting. If we used method=‘class’, CART would only split if one of the groups had a probability of voting above 50% and the other had a probability of voting less than 50% (since the predicted outcomes would be different). However, with regression trees, CART will split even if both groups have probability less than 50%.

Leave all the parameters at their default values. You can use the following command in R to build the tree:
CARTmodel = rpart(voting ~ civicduty + hawthorne + self + neighbors, data=gerber)
Plot the tree. What happens, and if relevant, why?


```{r}
library(rpart)
library(rpart.plot)

CARTmodel = rpart(voting ~ civicduty + hawthorne + self + neighbors, data=voters)
prp(CARTmodel)
```
a:  No variables are used (the tree is only a root node) - none of the variables make a big enough effect to be split on. No variables are used (the tree is only a root node) - none of the variables make a big enough effect to be split on.


## Problem 2.2 - Trees

Now build the tree using the command:
CARTmodel2 = rpart(voting ~ civicduty + hawthorne + self + neighbors, data=gerber, cp=0.0)
to force the complete tree to be built. Then plot the tree. What do you observe about the order of the splits?

```{r}
CARTmodel2 = rpart(voting ~ civicduty + hawthorne + self + neighbors, data=voters, cp=0.0)
prp(CARTmodel2)
```
a:  Neighbor is the first split, civic duty is the last. Neighbor is the first split, civic duty is the last. - correct


## Problem 2.3 - Trees

Using only the CART tree plot, determine what fraction (a number between 0 and 1) of "Civic Duty" people voted:
a: 0.31


## Problem 2.4 - Trees


Make a new tree that includes the "sex" variable, again with cp = 0.0. Notice that sex appears as a split that is of secondary importance to the treatment group.

In the control group, which gender is more likely to vote?
a: men
In the "Civic Duty" group, which gender is more likely to vote?
a: men
```{r}
CARTmodel3 = rpart(voting ~ civicduty + hawthorne + self + neighbors + sex, data=voters, cp=0.0)
prp(CARTmodel3)

prp(CARTmodel3)
```


## Problem 3.1 - Interaction Terms

We know trees can handle "nonlinear" relationships, e.g. "in the 'Civic Duty' group and female", but as we will see in the next few questions, it is possible to do the same for logistic regression. First, let's explore what trees can tell us some more.

Let's just focus on the "Control" treatment group. Create a regression tree using just the "control" variable, then create another tree with the "control" and "sex" variables, both with cp=0.0.

In the "control" only tree, what is the absolute value of the difference in the predicted probability of voting between being in the control group versus being in a different group? You can use the absolute value function to get answer, i.e. abs(Control Prediction - Non-Control Prediction). Add the argument "digits = 6" to the prp command to get a more accurate estimate.

```{r}

CARTmodel4 = rpart(voting ~ control, data = voters, cp=0.0)
prp(CARTmodel4, digits = 6)
abs(0.296638-0.34)
CARTmodel5 = rpart(voting ~ control + sex, data = voters, cp=0.0)
prp(CARTmodel5, digits = 6)
abs(0.345818-0.334176)
```
a: 0.043362


## Problem 3.2 - Interaction Terms

Now, using the second tree (with control and sex), determine who is affected more by NOT being in the control group (being in any of the four treatment groups):

a: They are affected about the same (change in probability within 0.001 of each other).

## Problem 3.3 - Interaction Terms

Going back to logistic regression now, create a model using "sex" and "control". Interpret the coefficient for "sex":
```{r}
logSex = glm(voting ~ sex + control, data = voters, family = binomial)
summary(logSex)
```
a: Coefficient is negative, reflecting that women are less likely to vote Coefficient is negative, reflecting that women are less likely to vote - correct


## Problem 3.4 - Interaction Terms


The regression tree calculated the percentage voting exactly for every one of the four possibilities (Man, Not Control), (Man, Control), (Woman, Not Control), (Woman, Control). Logistic regression has attempted to do the same, although it wasn't able to do as well because it can't consider exactly the joint possibility of being a women and in the control group.

We can quantify this precisely. Create the following dataframe (this contains all of the possible values of sex and control), and evaluate your logistic regression using the predict function (where "LogModelSex" is the name of your logistic regression model that uses both control and sex):

    
Possibilities = data.frame(sex=c(0,0,1,1),control=c(0,1,0,1))
predict(LogModelSex, newdata=Possibilities, type="response")

  
The four values in the results correspond to the four possibilities in the order they are stated above ( (Man, Not Control), (Man, Control), (Woman, Not Control), (Woman, Control) ). What is the absolute difference between the tree and the logistic regression for the (Woman, Control) case? Give an answer with five numbers after the decimal point.
```{r}
Possibilities = data.frame(sex=c(0,0,1,1),control=c(0,1,0,1))
predict(logSex, newdata=Possibilities, type="response")
abs(0.2908065-0.290456)
```
a: 0.0003505


## Problem 3.5 - Interaction Terms


So the difference is not too big for this dataset, but it is there. We're going to add a new term to our logistic regression now, that is the combination of the "sex" and "control" variables - so if this new variable is 1, that means the person is a woman AND in the control group. We can do that with the following command:

    
LogModel2 = glm(voting ~ sex + control + sex:control, data=gerber, family="binomial")

  
How do you interpret the coefficient for the new variable in isolation? That is, how does it relate to the dependent variable?
```{r}
LogModel2 = glm(voting ~ sex + control + sex:control, data=voters, family="binomial")
summary(LogModel2)
```



## Problem 3.6 - Interaction Terms


Run the same code as before to calculate the average for each group:

predict(LogModel2, newdata=Possibilities, type="response")

Now what is the difference between the logistic regression model and the CART model for the (Woman, Control) case? Again, give your answer with five numbers after the decimal point.


```{r}
predict(LogModel2, newdata=Possibilities, type="response")
abs(0.290456-0.2904558)
```
a: 2e-07


## Problem 3.7 - Interaction Terms

This example has shown that trees can capture nonlinear relationships that logistic regression can not, but that we can get around this sometimes by using variables that are the combination of two variables. Should we always include all possible interaction terms of the independent variables when building a logistic regression model?

a: no




#Letter Recognition

Letter recognition

One of the earliest applications of the predictive analytics methods we have studied so far in this class was to automatically recognize letters, which post office machines use to sort mail. In this problem, we will build a model that uses statistics of images of four letters in the Roman alphabet -- A, B, P, and R -- to predict which letter a particular image corresponds to.

Note that this is a multiclass classification problem. We have mostly focused on binary classification problems (e.g., predicting whether an individual voted or not, whether the Supreme Court will affirm or reverse a case, whether or not a person is at risk for a certain disease, etc.). In this problem, we have more than two classifications that are possible for each observation, like in the D2Hawkeye lecture. 

The file letters_ABPR.csv contains 3116 observations, each of which corresponds to a certain image of one of the four letters A, B, P and R. The images came from 20 different fonts, which were then randomly distorted to produce the final images; each such distorted image is represented as a collection of pixels, each of which is "on" or "off". For each such distorted image, we have available certain statistics of the image in terms of these pixels, as well as which of the four letters the image is. This data comes from the UCI Machine Learning Repository.

This dataset contains the following 17 variables:

letter = the letter that the image corresponds to (A, B, P or R)
xbox = the horizontal position of where the smallest box covering the letter shape begins.
ybox = the vertical position of where the smallest box covering the letter shape begins.
width = the width of this smallest box.
height = the height of this smallest box.
onpix = the total number of "on" pixels in the character image
xbar = the mean horizontal position of all of the "on" pixels
ybar = the mean vertical position of all of the "on" pixels
x2bar = the mean squared horizontal position of all of the "on" pixels in the image
y2bar = the mean squared vertical position of all of the "on" pixels in the image
xybar = the mean of the product of the horizontal and vertical position of all of the "on" pixels in the image
x2ybar = the mean of the product of the squared horizontal position and the vertical position of all of the "on" pixels
xy2bar = the mean of the product of the horizontal position and the squared vertical position of all of the "on" pixels
xedge = the mean number of edges (the number of times an "off" pixel is followed by an "on" pixel, or the image boundary is hit) as the image is scanned from left to right, along the whole vertical length of the image
xedgeycor = the mean of the product of the number of horizontal edges at each vertical position and the vertical position
yedge = the mean number of edges as the images is scanned from top to bottom, along the whole horizontal length of the image
yedgexcor = the mean of the product of the number of vertical edges at each horizontal position and the horizontal position

As usual, let's start with emptying the workspace

```{r}
rm (list = ls(all=T))
``` 



##Problem 1.1 - Predicting B or not B


Let's warm up by attempting to predict just whether a letter is B or not. To begin, load the file letters_ABPR.csv into R, and call it letters. Then, create a new variable isB in the dataframe, which takes the value "TRUE" if the observation corresponds to the letter B, and "FALSE" if it does not. You can do this by typing the following command into your R console:

```{r}
letters = read.csv("letters_ABPR.csv")
letters$isB = as.factor(letters$letter == "B")
```


Now split the data set into a training and testing set, putting 50% of the data in the training set. Set the seed to 1000 before making the split. The first argument to sample.split should be the dependent variable "letters$isB". Remember that TRUE values from sample.split should go in the training set.

```{r}
library(caTools)
set.seed(1000)
sampler = sample.split(letters$isB, SplitRatio = 0.5)
trainLetters = subset(letters, sampler == T)
testLetters = subset(letters, sampler == F)
```

Before building models, let's consider a baseline method that always predicts the most frequent outcome, which is "not B". What is the accuracy of this baseline method on the test set?

```{r}
table(trainLetters$isB)
table(testLetters$isB)
1175/(1175+383)
```

##Problem 1.2 - Predicting B or not B
Now build a classification tree to predict whether a letter is a B or not, using the training set to build your model. Remember to remove the variable "letter" out of the model, as this is related to what we are trying to predict! To just remove one variable, you can either write out the other variables, or remember what we did in the Billboards problem in Week 3, and use the following notation:

CARTb = rpart(isB ~ . - letter, data=train, method="class")

We are just using the default parameters in our CART model, so we don't need to add the minbucket or cp arguments at all. We also added the argument method="class" since this is a classification problem.

What is the accuracy of the CART model on the test set? (Use type="class" when making predictions on the test set.)



```{r}
library(rpart)
library(rpart.plot)
CARTb = rpart(isB ~ . -letter, data=trainLetters, method="class")
predictB = predict(CARTb, newdata = testLetters, type = "class")
table(predictB)
table(testLetters$isB, predictB) 
(1118+340)/length(testLetters$isB)
```


## Problem 1.3 - Predicting B or Not B

Now, build a random forest model to predict whether the letter is a B or not (the isB variable) using the training set. You should use all of the other variables as independent variables, except letter (since it helped us define what we are trying to predict!). Use the default settings for ntree and nodesize (don't include these arguments at all). Right before building the model, set the seed to 1000. (NOTE: You might get a slightly different answer on this problem, even if you set the random seed. This has to do with your operating system and the implementation of the random forest algorithm.)

What is the accuracy of the model on the test set?

```{r}
library(randomForest)
set.seed(1000)
bForest = randomForest(isB ~ . - letter, data = trainLetters)
forestPredictB = predict(bForest, newdata = testLetters)
table(testLetters$isB, forestPredictB)
(374+1165)/length(testLetters$isB)
```


In lecture, we noted that random forests tends to improve on CART in terms of predictive accuracy. Sometimes, this improvement can be quite significant, as it is here.


```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

```{r}

```

